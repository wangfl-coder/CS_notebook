# 反射机制

## 何为反射？

反射被称为框架（Spring、MyBatis等等）的灵魂，因为反射赋予我们运行时分析类和执行类中方法的能力。通过反射可以获得任何类的方法和属性，还可以调用这些方法。

## 反射应用场景

在我们业务场景中基本很少用到反射，但是正是因为反射才能使用我们的框架，像spring、Mybatis，这些框架大多使用了动态代理，而动态代理依赖反射。看下面示例代码，使用反射类Method来调用制定的代码。

```java
public class DebugInvocationHandler implements InvocationHandler {
    /**
     * 代理类中的真实对象
     */
    private final Object target;

    public DebugInvocationHandler(Object target) {
        this.target = target;
    }


    public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {
        System.out.println("before method " + method.getName());
        Object result = method.invoke(target, args);
        System.out.println("after method " + method.getName());
        return result;
    }
}

```

在Java中注解的实习也使用了反射，比如@Component就声明了一个Spring Bean。为什么能这样？是因为基于反射分析类，可以获取到类/方法/属性上的注解，然后再做进一步的处理。

## 反射的优缺点

- 优点：可以让我们代码更灵活，为各种框架开箱即用的功能提供了便利。
- 缺点：反射可以在运行时分析操作类，这样就会有安全性的问题，比如无视泛型类型参数安全性检查。另外反射的性能也稍微差些，但对框架影响不大。

## 反射实战

### 获取Class对象的四种方式

**1.知道具体类的情况下可以使用：**

```
Class alunbarClass = TargetObject.class;
```

但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化

**2.通过 `Class.forName()`传入类的路径获取：**

```
Class alunbarClass1 = Class.forName("cn.javaguide.TargetObject");
```

**3.通过对象实例`instance.getClass()`获取：**

```
TargetObject o = new TargetObject();
Class alunbarClass2 = o.getClass();
```

**4.通过类加载器`xxxClassLoader.loadClass()`传入类路径获取:**

```
class clazz = ClassLoader.LoadClass("cn.javaguide.TargetObject");
```

通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一些列步骤，静态块和静态对象不会得到执行

## 反射基本操作

看src/Invoke源码。