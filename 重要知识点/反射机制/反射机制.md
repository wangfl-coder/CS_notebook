# 反射机制

## 何为反射？

反射被称为框架（Spring、MyBatis等等）的灵魂，因为反射赋予我们运行时分析类和执行类中方法的能力（**在运行状态下，能获取类的属性和方法和操作类属性和方法。**）。通过反射可以获得任何类的方法和属性，还可以调用这些方法。说通俗点，反射赋予jvm动态编译的能力。没有反射类的元信息只能通过静态编译的形式实现（在编译期确定类型，绑定对象），而不能实现动态编译（在运行期确定类型，绑定对象）。也就是说在编译以后，程序在运行时的行为就是固定的了，如果要在运行时改变程序的行为，就需要动态编译。

## 反射应用场景

在我们业务场景中基本很少用到反射，但是正是因为反射才能使用我们的框架，像spring、Mybatis，这些框架大多使用了动态代理，而动态代理依赖反射。看下面示例代码，使用反射类Method来调用制定的代码。

```java
public class DebugInvocationHandler implements InvocationHandler {
    /**
     * 代理类中的真实对象
     */
    private final Object target;

    public DebugInvocationHandler(Object target) {
        this.target = target;
    }


    public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {
        System.out.println("before method " + method.getName());
        Object result = method.invoke(target, args);
        System.out.println("after method " + method.getName());
        return result;
    }
}

```

在Java中注解的实习也使用了反射，比如@Component就声明了一个Spring Bean。为什么能这样？是因为基于反射分析类，可以获取到类/方法/属性上的注解，然后再做进一步的处理。

### 情景一 ：不得已为之

- 有的类在编写程序无法通过new构造方法来创建实例，比如调用网络中的.class文件，这个时候是没有.java 文件的，所以无法进行编译得到.class文件，这种情况下就可以通过反射来得到类对象实例。
- 注解：注解本身起到标记的作用，需要用到反射，根据注解标记调用注解解释器。

### 情景二：动态加载

- 有的类在需要时再加载到jvm中，例如在Spring Aop中，动态代理的方法就使用反射来拦截特定方法。

### 情景三：避免把程序写死到代码里

因为java代码是先通过编译器将.java文件编译成.class的二进制字节码文件，因此如果我们使用new Person()来实例化对象person会出现的问题就是如果我们希望更换person的实例对象，就要在源代码种更改然后重新编译再运行，但是如果我们将person的实例对象类名等信息编写在配置文件中，利用反射的Class.forName(className)方法来实例化java对象（因为实例化java对象都是根据全限定名查找到jvm内存中的class对象，并根据class对象中的累信息实例化得到java对象，因此xml文件中只要包含了权限定类名就可以通过反射实例化java对象），那么我们就可以更改配置文件，无需重新编译。

## 反射的优缺点

- 优点：可以让我们代码更灵活，为各种框架开箱即用的功能提供了便利。
- 缺点：反射可以在运行时分析操作类，这样就会有安全性的问题，比如无视泛型类型参数安全性检查。另外反射的性能也稍微差些，但对框架影响不大。

## 反射实战

### 获取Class对象的四种方式

**1.知道具体类的情况下可以使用：**

```
Class alunbarClass = TargetObject.class;
```

但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化

**2.通过 `Class.forName()`传入类的路径获取：**

```
Class alunbarClass1 = Class.forName("cn.javaguide.TargetObject");
```

**3.通过对象实例`instance.getClass()`获取：**

```
TargetObject o = new TargetObject();
Class alunbarClass2 = o.getClass();
```

**4.通过类加载器`xxxClassLoader.loadClass()`传入类路径获取:**

```
class clazz = ClassLoader.LoadClass("cn.javaguide.TargetObject");
```

通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一些列步骤，静态块和静态对象不会得到执行

## 反射基本操作

看src/Invoke源码。