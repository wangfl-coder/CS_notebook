# 代理模式

代理模式是一种设计模式。简单的说是**使用代理对象来替代对目标对象的访问，这样可以在不更改目标对象的前提下，增加额外的功能，扩张目标对象的功能**。比如可以目标对象方法执行前后定义自己想要的操作。代理模式又分为两种代理方式。静态代理和动态代理。

# 静态代理

**静态代理中，我们对目标对象的每个方法的增强都是手动完成的（\*后面会具体演示代码\*），非常不灵活（\*比如接口一旦新增加方法，目标对象和代理对象都要进行修改\*）且麻烦(\*需要对每个目标类都单独写一个代理类\*)。** 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。从jvm层面来看，静态代理是在编译的时候已经将接口、实现类和代理类变成一个个实际的class文件。应用实例请看src/Static_Proxy。

## 静态代理实现步骤

1. 定义一个接口及其实现类
2. 创建代理类并同样实现该接口
3. 将目标对象注入到代理类，然后在代理类的对应方法调用目标类的对应方法。这样就可以通过代理类屏蔽目标对象的访问，并可以在方法执行前后定义自己的操作。

# 动态代理（动态生成代理对象）

相对静态代理来说，动态代理更灵活，不需要对每个目标类都编写一个对应的代理类。并且也不需要我们必须实现接口，我们可以直接代理实现类（CGLIB动态代理机制）。

从jvm的层面来看，动态代理是在运行时，动态生成类字节码，并加载到jvm中（按需生产被代理类的class字节码，不用像静态代理实现编译好写好的代理类和目标类）。动态代理平常在我们中开发很少用到，但是在框架中基本是一种必用到的技术。就Java 来说，动态代理的实现方式有很多，比如Jdk动态代理、CGLIB动态代理。

## Jdk动态代理机制

### 介绍

在Java动态代理机制中，InvocationHandler类和Proxy类是核心。Proxy类表示代理类，InvocationHandler是代理类用来调用目标类中方法的工具类。下面代码块是Proxy类使用频率最高的newProxyInstance()方法，作用是创建一个代理对象。

```java
public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h)
      {
      		....
      }
```

这个方法一共三个参数：

1. loader：类加载器，用来加载代理对象
2. interfaces：被代理类的实现接口
3. h：实现Invocationhandler接口的对象

要实现动态代理，还需要实现InvocationHandler来自定义处理逻辑，当动态代理对象调用方法会自动转到实现InvocationHandler接口的类的Invoke方法。你可以在Invoke()中自定义处理逻辑，比如在方法前后执行什么事。

### Jdk动态代理使用步骤

1. 定义一个接口及其实现类
2. 实现InvocationHandler接口，并重写Invoke方法，在Invoke方法中调用被代理对象的原生方法，并自定义处理逻辑。
3. 通过Proxy.newProxyInstance(ClassLoader loader，Class<?>[] interfaces，Invocationhandler h)，创建代理对象。

### 代码实例（见src/Jdk_Dynamic_Proxy）

1.定义短信的接口及其实现类

```java
public interface SmsService {
		String send(String message);
}
```

```java
public class SmsServiceImpl implements SmsService {
		public String send(String message){
				System.out.println("send message: " + message);
				return message;
		}
}
```

2.创建InvocationHandler接口实现类，并重写Invoke方法，且自定义逻辑。当我们动态代理对象调用原生方法时，实际上调用了invoke方法。

```java
public class DebugInvocationHandler implements InvocationHander {
		//真实对象
		private final Object target;
		
		public DebugInvocationHandler(Object target){
				this.target = target;
		}
		
		@Overrider
		public Object invoke(Object Proxy,Method method,Object[] args){
				//调用原生方法前，自定义逻辑
				System.out.println("before method " + method.getName());
				Object result = method.invoke(target,args);
				//调用方法后，自定义逻辑
				Systyem.out.println("after method " + method.getName());
				return result;
		}
}
```

3.定义代理对象的工厂类。

```java
public class JdkProxyFactory {
		public static Object getProxy(Object target){
				return Proxy.newProxyInstance(target.getClass().getClassLoader()，//目标类的类加载
						target.getClass.getInterfaces(),//代理需要实现的接口，可指定多个
						new DebugInvocationHandler(target);
				);
		}
}
```

4.实际使用

```java
SmsService smsService = (SmsService)JdkProxyFactory.getProxy(new SmsServiceImpl());
smsService.send("hello");
```

5.控制台打印

```
before method send
send message: hello
after method send
```

## CGLIB动态代理机制

### 介绍

Jdk代理机制最大的问题只能代理接口实现类，而cglib可以直接代理实现类。[CGLIB](https://github.com/cglib/cglib)(*Code Generation Library*)是一个基于[ASM](http://www.baeldung.com/java-asm)的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了[CGLIB](https://github.com/cglib/cglib)， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。

在cglib动态代理中，MethodInterceptor接口和Enhancer类是核心。MethodInterceptor接口相当于jdk动态代理的InvocationHandler接口，而Enhancer类相当于Proxy类的增强版。下面代码intercept方法用于拦截增强被代理类的方法。

```java
public interface MethodInterceptor
extends Callback{
    // 拦截被代理类中的方法
    public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args,
                               MethodProxy methodProxy) throws Throwable;
}
```

1.obj:被代理对象（需要增强的对象）

2.method：被拦截的方法

3.args：方法入参

4.methodProxy：用于调用原生方法

通过Enhancer类可以动态获取被代理类，当代理类调用方法，实际上是调用MethodInterceptor中的intercept方法，相当于InvocationHandler接口中invoke方法。

### CGLIB使用步骤

1. 定义一个接口
2. 创建MethodInterceptor接口实现类，并重写intercept方法
3. 通过Enhancer类，创建代理类

### 代码示例(见src/Cglib_Dynamic_Proxy)

**1.实现一个使用阿里云发送短信的类**

```java
package github.javaguide.dynamicProxy.cglibDynamicProxy;

public class AliSmsService {
    public String send(String message) {
        System.out.println("send message:" + message);
        return message;
    }
}
```

**2.自定义 `MethodInterceptor`（方法拦截器）**

```java
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

/**
 * 自定义MethodInterceptor
 */
public class DebugMethodInterceptor implements MethodInterceptor {


    /**
     * @param o           被代理的对象（需要增强的对象）
     * @param method      被拦截的方法（需要增强的方法）
     * @param args        方法入参
     * @param methodProxy 用于调用原始方法
     */
    @Override
    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        //调用方法之前，我们可以添加自己的操作
        System.out.println("before method " + method.getName());
        Object object = methodProxy.invokeSuper(o, args);
        //调用方法之后，我们同样可以添加自己的操作
        System.out.println("after method " + method.getName());
        return object;
    }

}
```

**3.获取代理类**

```java
import net.sf.cglib.proxy.Enhancer;

public class CglibProxyFactory {

    public static Object getProxy(Class<?> clazz) {
        // 创建动态代理增强类
        Enhancer enhancer = new Enhancer();
        // 设置类加载器
        enhancer.setClassLoader(clazz.getClassLoader());
        // 设置被代理类
        enhancer.setSuperclass(clazz);
        // 设置方法拦截器
        enhancer.setCallback(new DebugMethodInterceptor());
        // 创建代理类
        return enhancer.create();
    }
}
```

**4.实际使用**

```java
AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);
aliSmsService.send("java");
```

运行上述代码之后，控制台打印出：

```
before method send
send message:java
after method send
```

## Jdk动态代理 VS CGLIB动态代理

1. **Jdk动态代理只能代理实现接口的类或者接口类，CGLIB动态代理能够代理未实现任何接口的类**。另外，CGLIB动态代理通过生成一个被代理类的子类来拦截被代理类方法，因此不能代理final修饰的类。
2. 就二者效率来看，Jdk动态代理更优秀，并随着JDK的升级，不断优化。

## 动态代理 VS 静态代理

1. 动态代理更加灵活，静态代理需要为每一个目标类创建一个代理类，而动态代理并不需要。接口并且一旦新增方法，目标对象和代理对象都需要修改代码。
2. 从jvm层面来看，静态代理在编译阶段已经将目标类、代理类编译成class字节码文件，而动态代理是运行阶段动态生成class字节码文件，加载到jvm中。

# 总结

解释了代理模式。

详解静态代理和动态代理原理及实现步骤。并解释两者间的区别。