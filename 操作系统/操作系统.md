# 操作系统

## 操作系统的背后

从Windows操作系统开机的过程讲起：

1. 计算机演化路程？计算机怎么工作的？

   - 图灵机（计算模型）——>通用图灵机——>计算机
   - 将程序和数据存储在计算机内部的存储器里，程序在控制器下取指执行，直到结束。

2. 打开电源，计算机执行的第一条指令是什么？

   - X86 PC刚开机时处于实模式（和保护模式对应，实模式的寻址CS：IP（CS左移4位+IP），和保护模式不一样）
   - 开机时，CS=0xFFFF；IP=0x0000
   - 寻址0xFFFF0（ROM BIOS映射区，刚上电唯一有代码的地方）
   - 检查RAM，键盘、显示器、软硬磁盘
   - 将磁盘0磁道0扇区读入0x7c00处，读入操作系统的引导程序（512B）
   - 设置cs=0x07c0，ip=0x0000（开始执行引导程序）

3. 引导扇区的故事

   - 引导扇区就是启动设备的第一个扇区，开机时按住del键可进入启动设备设置界面，可以设置为光盘启动！

   - 启动设备信息被设置在CMOS（存储实时钟和硬件配置的信息的地方）中

   - 所以我们硬盘上存放着开机后执行的第一段可以控制的程序

   - 引导扇区代码bootsect.s（s表示汇编代码)，代码文件是为了读入setup扇区和System模块

     ![屏幕快照 2021-05-17 下午6.01.42](https://tva1.sinaimg.cn/large/008i3skNly1gqlkx6p0kkj31a00psh94.jpg)

     ![屏幕快照 2021-05-17 下午6.08.00](https://tva1.sinaimg.cn/large/008i3skNly1gqll3nfrskj31b20qw4ja.jpg)

4. setup模块，即setup.s

   - setup将完成OS启动前的设置(1.读取内存参数，进行内存管理。2.挪动setup位置，将System模块移动到0x0地址。3.读取硬件参数，进行硬件管理。4.进入保护模式（寻址空间从16位切换到32位模式）。)

     ![屏幕快照 2021-05-17 下午7.40.39](https://tva1.sinaimg.cn/large/008i3skNly1gqlns1g2lmj31ak0q4az7.jpg)

     ![屏幕快照 2021-05-17 下午7.41.53](https://tva1.sinaimg.cn/large/008i3skNly1gqlnteaov2j31ao0q4ndo.jpg)

5. system模块由许多文件编译而成，head.s

   - 想要执行System模块，依赖bootsect.s和setup.s的是否加载完和System文件是否编译完成

   - head.s相当于一个控制程序，控制执行哪些C文件（main函数等等）

   - main函数（初始化内存，初始化键盘、等等，针对硬件初始化相应的数据结构）

     ![屏幕快照 2021-05-17 下午8.15.20](https://tva1.sinaimg.cn/large/008i3skNly1gqlos585yyj31b00qgh7b.jpg)

   - men_init（），初始化内存mem_map表格，记录内存使用情况（分页）

     ![屏幕快照 2021-05-17 下午8.18.10](https://tva1.sinaimg.cn/large/008i3skNly1gqlov2xc13j31am0qe1aq.jpg)


## 操作系统接口

调用接口的三种方式：命令行（shell）、图形按钮、应用程序

### 命令行

命令行一般通过shell去执行，shell也是一段程序，当系统模块初始化完成后，会运行shell程序，shell程序会一直等到命令输入，命令输入后再调用系统接口去执行。以下是截图。

![屏幕快照 2021-05-18 上午11.05.58](https://tva1.sinaimg.cn/large/008i3skNly1gqmeis80i3j31ae0q4kgz.jpg)

### 图形按钮

- 鼠标点击、键盘按下后。。。等等硬件输入是基于消息队列实现的。从下图可以看出从消息队列中取出消息后，判断属于哪种时间，然后进行相应的处理。

  ![image-20210525160715562](https://i.loli.net/2021/05/25/W8zsXo3uafQ2yct.png)

### 通过应用程序调用

操作系统接口称为系统调用，表现为函数调用。

### 系统接口（系统调用）

![屏幕快照 2021-05-18 上午11.29.06](https://tva1.sinaimg.cn/large/008i3skNly1gqmf6w81y6j31am0qm1cm.jpg)

系统调用统一，服从POSIX标准，方便应用程序开发。

## 系统调用的实现

### 实现一个whoami系统调用

![image-20210525193555712](https://i.loli.net/2021/05/25/5MvTyUlOpEA9dqF.png)

- 为什么不能随意的调用数据？不能随意的jmp?

  因为这是不安全的，随意的调用数据或者jmp会改变内核空间的数据。

- 怎么实现不能随意调用数据？

  ![image-20210525194401747](C:/Users/Admin/AppData/Roaming/Typora/typora-user-images/image-20210525194401747.png)

- 怎么调用内核的数据？

  ![image-20210525195204902](https://i.loli.net/2021/05/25/G46e2ro7ATaykXj.png)

  ![image-20210525195556398](https://i.loli.net/2021/05/25/Svj26rOCKVxhDf9.png)

## CPU管理

### 多进程

- CPU的工作原理

  1.设置好PC的初值。2.取PC地址的指令并传送到CPU去执行。

  ![image-20210525202112268](https://i.loli.net/2021/05/25/CqrzQoBsmaD1NWT.png)

- CPU管理原理

  - 并发：让CPU交替执行多个任务，当单个任务执行到不需要CPU的地方，CPU可以转而执行另一个任务，这样增加CPU的利用率。

  - 怎么做到交替执行多个程序？只要修改PC寄存器的值就行了吗？

    不仅需要改变PC的值，也要记录进程上次执行的状态信息，以便切回执行时能够继续按原来的状态执行下去。

    ![image-20210525204109175](https://i.loli.net/2021/05/25/ubL3ld7PjU9vpI6.png)

- 多进程

  - 进程

    ![image-20210525204300451](https://i.loli.net/2021/05/25/jWEOClvdrzQMV81.png)

  - 多进程如何组织？

    使用PCB记录进程的信息，并在队列中进行状态推进。

    ![image-20210525211511751](https://i.loli.net/2021/05/25/g2GQMVyz6eKIwjT.png)

    ![image-20210525211148975](https://i.loli.net/2021/05/25/gdwHx27JGaCf5Qu.png)

  - 多进程如何切换？

    ![image-20210525212110921](https://i.loli.net/2021/05/25/CryfoQw93SIltD1.png)

  - 进程如何调度？（就绪队列中哪个进程先执行？）

    ![image-20210525212333558](https://i.loli.net/2021/05/25/aJnTNQgKsCdZPjY.png)

    ![image-20210525212453326](https://i.loli.net/2021/05/25/ouPAV6CcxjXYfdt.png)

  - 多进程如何影响？

    ![image-20210525212840551](https://i.loli.net/2021/05/25/P1jgLUt7wXBhl59.png)

    解答：

    ![image-20210525213036081](https://i.loli.net/2021/05/25/C4dwgkMPKqFabTe.png)

  - 总结

    ![image-20210525214032214](https://i.loli.net/2021/05/25/Usx4rqCVfMeHD8g.png)

### 用户级线程

# 内存管理

## 内存使用与分段

### 内存使用

- 内存使用基本思想：程序放到内存，CPU取内存中指令执行
- 内存使用流程(可执行程序执行流程)
  1. 首先在内存中寻找到一块空闲的内存块
  2. 为可执行程序创建一个进程,并初始化进程的PCB
  3. 将进程载入内存,并计算进程的入口(**基地址+偏移量**)
     - 基地址确定时段(基地址重定位)可分为三种:
       - 程序编译时:编译时确定基地址,但是编译时并不知道内存空闲地址,所以只适用于程序固定的情况,类似于嵌入式系统,程序永远在固定的位置进行执行.
       - 程序载入时:在程序载入时确定基地址,但是存在进程载入后会换入换出进程的情况,比如当进程1阻塞时,会被换出,若进程2阻塞时进程1就会被换进,这个时候基地址已经发生了变化,而载入时已经确定了基地址,这样程序的执行就会发生错误.
       - 程序运行时:程序运行时确定基地址(初始化在PCB中),这样在发生进程交换时,只需要修改PCB中基地址的值,进程执行时,将基地址寄存器置为当前执行进程PCB中基地址即可.
  4. 设置PC的值,取指执行.
- 总结:内存的使用的重点就是进程基地址重定位,程序运行时确定基地址并根据逻辑地址计算出真正的物理地址.

### 分段

- 引入分段

  - 程序并不是完整的放入到内存中,而是分段放入到内存中,采用分治的思想,每一段都有不同的功能和读写权限,这样能够提高内存的利用率;如常见的程序可以分为代码段、数据段和堆栈段等等.
  - 程序员眼中的程序分段(编译时完成):![image-20210528142912852](https://i.loli.net/2021/05/28/qrF24bWSUgGB1tD.png)

  - 定位到段内指令的方式:**<段号,段内偏移>**

- 段程序重定位:当运行段程序就必须定位到实际物理地址,就需要段基址和偏移量,而段基址被维护在段表中,段表也是存储在PCB中.

- 段表**(LDT)**

  - ![](https://i.loli.net/2021/05/28/4Z5Lz7BvTboyhi3.png)
  - 应用进程的段表就是LDT,其实GDT表就是操作系统的段表.

- 总结:程序分段放入到内存中,每个进程PCB维护一个段表,进程的段表就是LDT,操作系统的段表就是GDT,所以程序在内存中的使用就是GDT+LDT.

## 内存分区与分页

### 分区(找空闲内存块,怎么割)

一般对虚拟内存进行分区,对实际物理内存进行分页.

- 固定分区:内存等分K个分区
  - 缺陷:程序的内存需求不一样,可能需要更大,也可能需要更小
- 可变分区:按需分配
  - 操作系统维护一个空闲分区表和已分配分区表,每次分配内存都会查询和更新该表
  - 当给一段程序分配内存时有三种方式:
    - ![image-20210528152057183](https://i.loli.net/2021/05/28/Ume8STAjiEB6Znl.png)
    - 首先适配:取空闲分区表最近的分区,优点就是比较快.
    - 最佳适配:取空闲分区最接近需求内存大小的分区,这样会产生一些比较长度小的分区
    - 最差适配:取空闲分区比需求内存最大的分区,这样分配完会得到比较均匀的分区.

### 分页

- 可变分区造成的问题

  ![image-20210528152829103](https://i.loli.net/2021/05/28/2ZDQoeWP8gwnbNO.png)

- 分页:将实际物理内存分为固定大小的页,当段程序载入内存时,会将段打散存入不同的页中,所以就会产生一个实际问题,如何确定基址,和段的解决办法一致,维护一个页表,通过页表来确定基址,再加上偏移量进而计算出真正的物理地址.

- 页表(计算实际物理地址)

  ![image-20210528204843888](https://i.loli.net/2021/05/28/gJs37P1NlBxKutZ.png)

  - 例子,在上图指令mov [0x2240], %eax中,[0x2240]依然是一个逻辑地址,是一个相对页面0的逻辑地址,通过这个逻辑地址和页面size可以计算出真正的物理地址.

  - 计算过程:

    - 2240除以页面size(4k),商就是页号,余数就是偏移量,除以4K相当于右移12位,所以商就是2,余数就是0x240,查询页表得知页号2对应的页框时3,所以实际物理地址就是3乘以页面size(4k)+240,实际物理地址就是0x3240.

      

## 多级页表和快表

- 引入原因:
  - 当进程占用内存较大时,对应分配的页会较多,这就造成页表非常大,通常一个页表项占用4K内存,如果有一个4G的进程就有1M的页表,这样就会造成内存浪费.
  - 如果尝试只将用到的页表项存入到页表中,页表的大小就会大大减小,但是页号就会不连续,对页表的查找就会从顺序查找变成折半查找,这就会造成查找时多次访问内存(访问内存非常耗时),降低程序的性能.

